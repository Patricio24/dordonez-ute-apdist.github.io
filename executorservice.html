<html>
  <head>
    <title>Executor Completion Service</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<meta name="description" content="" />
	<meta name="keywords" content="" />
	<link rel="stylesheet" href="assets/css/main.css" />
  </head>
  <body class="is-preload">
  <!-- Header -->
			<header id="header">
				<a class="logo" href="index.html">Universidad UTE</a><img src="images/logo2.png" height="80px" width="160px"/>
				<nav>
					<a href="#menu">Menu</a>
				</nav>
			</header>
	
	<!-- Nav -->
			<nav id="menu">
				<ul class="links">
					<li><a href="index.html">Home</a></li>
					<li><a href="generic.html">Introducción a las Aplicaciones distribuidas</a></li>
					<li><a href="transformaciones.html">Aplicaciones distribuidas en la vida real</a></li>
					<li><a href="crear_hilos.html">Hilos simples y heredados</a></li>
					<li><a href="executorservice.html">Ejecutores</a></li>
					<li><a href="etiquetas.html">Sincronización</a></li>
				</ul>
			</nav>
			
	<!-- Banner -->
			<section id="banner">
				<div class="inner">
					<h1>APLICACIONES DISTRIBUIDAS</h1>
					<!--<p>Audio, imagen, video, transiciones y animaciones.</p>-->
				</div>
				<video autoplay loop muted playsinline src="images/ute.mp4"></video>
			</section>
	
	<section class="wrapper">
		<div class="inner">
        <h1>EXECUTOR COMPLETION SERVICE</h1>
        	<header>
			<br><br>
            <font style="vertical-align: inherit; color:#30F; font-size:24px">Interfaz pública <strong style="color:#30F">CompletionService</strong> </font>
            <br><br>
            <p>Un servicio que desacopla la producción de nuevas tareas asincrónicas del consumo de los resultados de las tareas completadas.</p>
            	<ul>
                	<ul>
                	<li>Los productores envían tareas para su ejecución.</li>
                    <li>Los consumidores toman las tareas completadas y procesan sus resultados en el orden en que las completan.</li>
                    <li>Un servicio de finalización se puede utilizar, por ejemplo, para gestionar E / S asíncronas, en las que las tareas que realizan lecturas se envían en una parte de un programa o sistema, y ​​luego se actúa en una parte diferente del programa cuando se completan las lecturas, posiblemente en un orden diferente de lo que fueron solicitados.</li>
                </ul>
               </ul> 
            <br>
			<p>La clase en Java <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorCompletionService.html"><code>ExecutorCompletionService</code></a>, permite enviar una serie de tareas como Callables y obtener el resultado interactuando con el Servicio de finalización como una cola. Por lo general, un <strong>CompletionService</strong> se basa en un proceso separado <strong>Executor</strong> para ejecutar realmente las tareas, en cuyo caso CompletionService solo administra una cola de finalización interna.</p><br>
			</header>
            
            
            <table border="1" cellpadding="7" cellspacing="0">
			<thead>
				<tr style="background-color: rgb(204, 204, 204);">
					<td colspan="2" style="text-align: center;">
						<b style="color:#000; font-size:
                        16px">METODOS</b></td>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td width="34%">
									<b>poll( )</b></td>
								<td width="66%">
									Recupera y elimina el futuro que representa la siguiente tarea completada o nulo si no hay ninguno presente.</td>
							</tr>
							<tr>
								<td>
									<b><strong>poll</strong> (long timeout, <strong>TimeUnit</strong> unit)</b></td>
								<td>Recupera y elimina el futuro que representa la siguiente tarea completada, esperando si es necesario hasta el tiempo de espera especificado si aún no hay ninguno presente.</td>
							</tr>
							<tr>
								<td>
									<b>submit (Callable<V> task)</b></td>
								<td>
									Envía una tarea de devolución de valor para su ejecución y devuelve un futuro que representa los resultados pendientes de la tarea.</td>
							</tr>
							<tr>
								<td>
									<b>	submit (Runnable task, V result)</b></td>
								<td>
									Envía una tarea Ejecutable para su ejecución y devuelve un Futuro que representa esa tarea.</td>
							</tr>
                            <tr>
								<td>
									<b>take( )</b></td>
								<td>
									Recupera y elimina el Futuro que representa la siguiente tarea completada, esperando si aún no hay ninguna presente.</td>
							</tr>
				
							</tr>
						</tbody>
					</table>
                    
                    <br>
                    <font style="vertical-align: inherit;"><strong>Ejemplos de uso :</strong> Supongamos que tiene un conjunto de solucionadores para un problema determinado, cada uno de los cuales devuelve un valor de algún tipo Result, y le gustaría ejecutarlos simultáneamente, procesando los resultados de cada uno de ellos que devuelven un valor no nulo, en algún método use(Result r). <br><br><strong> Podrías escribir esto como: </strong></font>
                    </br></br>
                    <div class="content" style="overflow:scroll; width:600px; height:400px;background-color: lightblue" >
                   <pre> 
                    <code>void solve(Executor e,<font></font>
            Collection&lt;Callable&lt;Result&gt;&gt; solvers)<font></font>
     throws InterruptedException, ExecutionException {<font></font>
     CompletionService&lt;Result&gt; ecs<font></font>
         = new ExecutorCompletionService&lt;Result&gt;(e);<font></font>
     for (Callable&lt;Result&gt; s : solvers)<font></font>
         ecs.submit(s);<font></font>
     int n = solvers.size();<font></font>
     for (int i = 0; i &lt; n; ++i) {<font></font>
         Result r = ecs.take().get();<font></font>
         if (r != null)<font></font>
             use(r);<font></font>
     }<font></font>
 }</code>
 </pre>
                    
                    </div>
                    <br><br>
                    <p>Aquí es donde <strong>ExecutorCompletionService</strong>interviene. Es una envoltura delgada <strong>ExecutorService</strong> que "recuerda" todas las tareas enviadas y le permite esperar la primera tarea completada , en lugar de la primera tarea enviada. 
                    <br>
                    En cierto sentido <strong>ExecutorCompletionService</strong> mantiene un identificador para todos los Future objetos intermedios y una vez que alguno de ellos termina, se devuelve. 
                    </p>
            
            	</section>
  </body>
  <!-- Footer -->
			<footer id="footer">
				<div class="inner">
					<div class="content">

							<h4>Universidad UTE &copy 2019</h4>

						</section>
					</div>
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

</html>